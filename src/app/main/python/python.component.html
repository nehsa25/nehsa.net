<mat-card class="card" [class.vampire]="userService.appIsDark()" [class.angel]="!userService.appIsDark()">
    <mat-card-header>
        <mat-card-title>
            <h1 data-testid="header-title">Python is rad!</h1>
        </mat-card-title>
    </mat-card-header>
    <mat-card-content>
        <div class="commentgrid">
            <div class="topics">
                <div>Related Content:
                    <ul class="condensed">
                        <li><a routerLink="/design">Software Development</a></li>
                        <li><a routerLink="/webdev-frameworks">Web Development Frameworks</a></li>
                        <li><a routerLink="/agile">Agile</a></li>
                        <li><a routerLink="/angular">Angular</a></li>
                        <li><a routerLink="/csharp">C#</a></li>
                        <li><a routerLink="/go">Golang</a></li>
                        <li><a routerLink="/java">Java</a></li>
                        <li><a routerLink="/python">Python</a></li>
                        <li><a routerLink="/react">React</a></li>
                        <li><a routerLink="/security">Security</a></li>
                        <li><a routerLink="/testing">Testing</a></li>
                        <li><a routerLink="/typescript">Typescript</a></li>                    
                    </ul>
                </div>
                <div>
                    <ul>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Coding Conventions</mat-panel-title>
                                    <mat-panel-subtitle><a
                                            href="https://peps.python.org/pep-0008/">PEP8</a></mat-panel-subtitle>
                                </mat-expansion-panel-header>
                                <table>
                                    <tr>
                                        <th>Type</th>
                                        <th style="width: 300px;">Naming Convention</th>
                                        <th>Examples</th>
                                    </tr>
                                    <tr>
                                        <td>Function</td>
                                        <td>Use a lowercase word or words. Separate words by underscores to improve
                                            readability.
                                        </td>
                                        <td>x, var, python_variable</td>
                                    </tr>
                                    <tr>
                                        <td>Variable</td>
                                        <td>Use a lowercase single letter, word, or words. Separate words with
                                            underscores to
                                            improve readability.</td>
                                        <td>function, python_function</td>
                                    </tr>
                                    <tr>
                                        <td>Class</td>
                                        <td>Start each word with a capital letter. Don’t separate words with
                                            underscores. This
                                            style
                                            is called camel case or Pascal case.</td>
                                        <td>Model, PythonClass</td>
                                    </tr>
                                    <tr>
                                        <td>Method</td>
                                        <td>Use a lowercase word or words. Separate words with underscores to
                                            improve
                                            readability.
                                        </td>
                                        <td>class_method, method</td>
                                    </tr>
                                    <tr>
                                        <td>Constant</td>
                                        <td>Use an uppercase single letter, word, or words. Separate words with
                                            underscores to
                                            improve readability.</td>
                                        <td>function, python_function</td>
                                    </tr>
                                    <tr>
                                        <td>Module</td>
                                        <td>Use a short, lowercase word or words. Separate words with underscores to
                                            improve
                                            readability.</td>
                                        <td>module.py, python_module.py</td>
                                    </tr>
                                    <tr>
                                        <td>Package</td>
                                        <td>Use a short, lowercase word or words. Don’t separate words with
                                            underscores.</td>
                                        <td>package, pythonpackage</td>
                                    </tr>
                                </table>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Types in Python</mat-panel-title>
                                    <mat-panel-subtitle>Constructor is: <span class="code">def say_hello(name: str)
                                            -> str:</span></mat-panel-subtitle>
                                </mat-expansion-panel-header>Python does nearly everything for you
                                in regards with variables types, but with later versions of Python, you can now
                                have more control, and it can be helpful for several reasons. To me, most
                                importantly,
                                it is
                                better for earlier detecting coding errors. When everything is dynamic, making
                                mistakes
                                and passing the wrong type is easy. These mistakes are often only noticed at runtime
                                when things blow up dramatically.<br><br>
                                Working with types explicity can mitigate this.<br><br>
                                For example:<br>
                                <br>The old, somewhat sad way:
                                <div class="code">
                                    <pre>
def __init__(self, room, description):
    ...
</pre>
                                </div><br>
                                The new, happier way:
                                <div class="code">
                                    <pre>
def __init__(self, room:str, description: str) -> None:
    ...
</pre>
                                </div>
                                <br>
                                In the example above, we ensure that the variables "room" and "description" are
                                strings and that the return value is a
                                None. If the wrong type is passed or we attempt to return something, Python will
                                throw an error (an error will be thrown regardless as you cannot return something
                                from a constructor but that's beside the point).
                                <br><br>
                                Example 2:
                                <div class="code">
                                    <pre>
def say_hello(name: str) -> str:
    return "Hello " + name
</pre>
                                </div>
                                <br>
                                Similar but we're also indicating that the return type must be a string.

                                Common built-in data types:
                                <ul class="condensed">
                                    <li>str</li>
                                    <li>int</li>
                                    <li>float</li>
                                    <li>bool</li>
                                    <li>list</li>
                                    <li>tuple</li>
                                    <li>set</li>
                                    <li>dict</li>
                                </ul><br><br>
                                Getting the type of a variable: <span class="code">type(x)</span>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Getters & Setters in Python = Don't. Use properties
                                        instead.</mat-panel-title>
                                    <mat-panel-subtitle>
                                        <span class="code">&#64;property</span>
                                    </mat-panel-subtitle>
                                </mat-expansion-panel-header>
                                In many languages, it's sacrilege to not use assessors when working with classes
                                but not with Python. In Python, you can use properties to get and set values. This
                                is a much cleaner way to work with classes and is more Pythonic. <br><br>

                                <div class="code">
                                    <pre>
&#64;property
async def description(self):
    return await self.get_player_description()
p.description = await player.description
</pre>
                                </div><br><br>
                                By using the property decorator, you can access the method as if it were a
                                property:<br>
                                <span class="code">p.description = await player.description</span><br><br>
                                More complexity can be had by using the setter decorator.<br><br>This allows you to
                                also
                                set description:<br>
                                <div class="code">
                                    <pre>
&#64;property
def description(self):
    return self._description

&#64;description.setter
def description(self, value):
    if value == "":
        raise ValueError("Description cannot be empty")
    self._description = value
</pre>
                                </div>

                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Threading vs. Async vs. multiprocessing</mat-panel-title>
                                </mat-expansion-panel-header>
                                Important definitions when discussing threading:<br>
                                <dl>
                                    <dt>Sync function</dt>
                                    <dd>A &quot;blocking&quot; activity. Nothing else on the thread can proceed
                                        until this returns. Sync functions are inconsiderate.
                                    </dd>
                                    <dt>Async function</dt>
                                    <dd>Indicates that a function is a coroutine which can be waited upon (awaited).
                                        Async functions run within a single thread. They work by starting an "Event
                                        Loop," which allows them to work on other things while "awaiting" longer
                                        running tasks. See <a
                                            href="https://docs.python.org/3/library/asyncio.html">asyncio</a></dd>
                                    <dt>Registers</dt>
                                    <dd>A processor register is a quickly accessible location available to a
                                        computer's processor</dd>
                                    <dt>Heap</dt>
                                    <dd>Memory available to process</dd>
                                    <dt>Stack</dt>
                                    <dd>Memory set aside for this thread. Contents lost after thread ends.</dd>
                                    <dt>Threads</dt>
                                    <dd>A thread has it's own registers and stack.
                                        Allows you to run multiple threads in parallel. See <a
                                            href="https://docs.python.org/3/library/concurrent.futures.html">concurrent.futures</a>
                                    </dd>
                                    <dt>Multithreaded Applications</dt>
                                    <dd>Multiple threads running in parallel. Threads can access shared process
                                        information. See <a
                                            href="https://docs.python.org/3/library/concurrent.futures.html">concurrent.futures</a>
                                    </dd>
                                    <dt>Process</dt>
                                    <dd>An instance of a program. Threads run within a process.
                                    </dd>
                                    <dt>Multiprocess Applications</dt>
                                    <dd>Threads/multithreading is suitable for IO-bound situations - you need to
                                        wait on a user interaction or a web app to return data and don't have to
                                        stop other activities from occurring. Though Python can only execute one
                                        thread at a time, if the operation is CPU-intensive, multiprocessing is the
                                        way to go. If you have a four-core CPU using threading, each thread gets
                                        slices of attention from one of the CPUs (but very fast); multiprocessing
                                        gets an entire thread, so real concurrency is achieved. You may wish to have
                                        an application containing multiple processes. Browsers are often used as an
                                        example of multi-process applications, although in their case, it's also for
                                        security. Each tab usually has a different process, so if something terrible
                                        happens to one tab like you visit a malicious website, the other tabs will
                                        remain functional.  See <a
                                            href="https://docs.python.org/3/library/multiprocessing.html">multiprocessing</a>
                                        <br><br><span class="comment">As processes do not share memory,
                                            pipes, and queues are used to communicate between processes in
                                            multi-process applications.</span>
                                    </dd>
                                    <dt>Pipes</dt>
                                    <dd>Direction of communucation is unidirectional (one-way).</dd>
                                    <dt>Queues</dt>
                                    <dd>Bi-directional communcation</dd>
                                </dl>
                                <br><br>
                                <ol>
                                    <li>Synchronously: A disgraced fully synchronous function. We will only proceed
                                        to the next iteration of the loop when the previous returns. OK if the call
                                        is near instantaneous, but any delay quickly adds up
                                        <div class="code">
                                            <pre>
def sync_example(self):        
    for i in range(self.number_iterations):
        time.sleep(0.1)
# sync
t.sync_example()                                         
        </pre>
                                        </div>
                                    </li>
                                    <li>Asynchronously (threading - executor.submit):<br>
                                        <div class="code">
                                            <pre>
def thread_example(self, i):
    time.sleep(0.1)
            
def async_threading_example(self):
    with ThreadPoolExecutor() as executor:
        executor.<span
        class="important">submit</span>(self.thread_example, range(self.number_iterations))   

# threading
t.async_threading_example()
        </pre>
                                        </div>
                                    </li>
                                    <li>Asynchronously (threading - executor.map):<br>
                                        <div class="code">
                                            <pre>
def thread_example(self, i):
    time.sleep(0.1)
            
def async_threading_example(self):
    with ThreadPoolExecutor() as executor:
        executor.<span
        class="important">map</span>(self.thread_example, range(self.number_iterations))   

# threading
t.async_threading_example()
        </pre>
                                        </div>
                                        <span class="comment">Notice the nearly similar syntax of <span
                                                class="importantish">the map</span> to <span
                                                class="importantish">submit</span>.
                                            The main difference between the two is that submission has more power
                                            but is also more complex. I use maps unless there's a specific reason
                                            not to. Submitting allows for more control, such as canceling threads.
                                            You've returned a future object and have more flexibility in arguments
                                            passed to thread functions.</span>
                                    </li>
                                    <li>Asynchronously (AsyncIO):<br>
                                        <div class="code">
                                            <pre>
# the "thread/task" function that's doing the actual work
async def sleep_asyncio_example(self):
    await asyncio.sleep(0.1)
        
# the function that will call the above function
async def sleep_asyncio_thread_example(self):
    tasks = []
    for i in range(self.number_iterations):
        tasks.append(asyncio.create_task(self.sleep_asyncio_example()))
    await asyncio.gather(*tasks) #<mat-icon class="comment-arrow">arrow_back</mat-icon> the magic
    
# starts the event look
loop = asyncio.new_event_loop()

# starts our async function
loop.run_until_complete(t.sleep_asyncio_thread_example())
        </pre>
                                        </div>
                                    </li>
                                </ol>
                                <br><br>
                                Timings (.1 sleep):
                                <div class="code">
                                    <pre>
115.96500 seconds
Results from threading examples, quickest first:
Threading (submit), iterations: 1, sleep: 2 took 0.00043 seconds
Threading (submit), iterations: 20, sleep: 2 took 0.00055 seconds
Threading (submit), iterations: 2, sleep: 0.5 took 0.00063 seconds
Threading (submit), iterations: 1, sleep: 1 took 0.00074 seconds
Threading (submit), iterations: 2, sleep: 1 took 0.00075 seconds
Threading (submit), iterations: 5, sleep: 2 took 0.00090 seconds
Threading (submit), iterations: 2, sleep: 0.1 took 0.00091 seconds
Threading (submit), iterations: 20, sleep: 0.1 took 0.00098 seconds
Threading (submit), iterations: 5, sleep: 1 took 0.00101 seconds
Threading (submit), iterations: 20, sleep: 1 took 0.00111 seconds
Threading (submit), iterations: 5, sleep: 0.5 took 0.00121 seconds
Threading (submit), iterations: 5, sleep: 0.1 took 0.00123 seconds
Threading (submit), iterations: 1, sleep: 0.1 took 0.00125 seconds
Threading (submit), iterations: 1, sleep: 0.5 took 0.00137 seconds
Threading (submit), iterations: 20, sleep: 0.5 took 0.00143 seconds
Threading (submit), iterations: 2, sleep: 2 took 0.00145 seconds
Multi-process, iterations: 2, sleep: 1 took 0.01941 seconds
Multi-process, iterations: 1, sleep: 1 took 0.01945 seconds
Multi-process, iterations: 2, sleep: 0.1 took 0.02206 seconds
Multi-process, iterations: 5, sleep: 0.5 took 0.02561 seconds
Multi-process, iterations: 20, sleep: 1 took 0.02617 seconds
Multi-process, iterations: 5, sleep: 2 took 0.02664 seconds
Multi-process, iterations: 1, sleep: 0.5 took 0.02719 seconds
Multi-process, iterations: 5, sleep: 1 took 0.02737 seconds
Multi-process, iterations: 20, sleep: 0.5 took 0.02885 seconds
Multi-process, iterations: 2, sleep: 2 took 0.02916 seconds
Multi-process, iterations: 5, sleep: 0.1 took 0.02998 seconds
Multi-process, iterations: 20, sleep: 0.1 took 0.03079 seconds
Multi-process, iterations: 2, sleep: 0.5 took 0.03856 seconds
Multi-process, iterations: 1, sleep: 0.1 took 0.04133 seconds
Multi-process, iterations: 1, sleep: 2 took 0.05037 seconds
Sync, iterations: 1, sleep: 0.1 took 0.10008 seconds
Multi-process, iterations: 20, sleep: 2 took 0.10142 seconds
asyncio, iterations: 2, sleep: 0.1 took 0.10341 seconds
asyncio, iterations: 5, sleep: 0.1 took 0.10413 seconds
asyncio, iterations: 20, sleep: 0.1 took 0.10925 seconds
asyncio, iterations: 1, sleep: 0.1 took 0.11280 seconds
Sync, iterations: 2, sleep: 0.1 took 0.20087 seconds
Sync, iterations: 1, sleep: 0.5 took 0.50058 seconds
Sync, iterations: 5, sleep: 0.1 took 0.50187 seconds
asyncio, iterations: 5, sleep: 0.5 took 0.50450 seconds
asyncio, iterations: 1, sleep: 0.5 took 0.51174 seconds
asyncio, iterations: 2, sleep: 0.5 took 0.51452 seconds
asyncio, iterations: 20, sleep: 0.5 took 0.51556 seconds
Sync, iterations: 1, sleep: 1 took 1.00023 seconds
Sync, iterations: 2, sleep: 0.5 took 1.00093 seconds
asyncio, iterations: 1, sleep: 1 took 1.00201 seconds
asyncio, iterations: 20, sleep: 1 took 1.00771 seconds
asyncio, iterations: 2, sleep: 1 took 1.00982 seconds
asyncio, iterations: 5, sleep: 1 took 1.01503 seconds
Sync, iterations: 5, sleep: 2 took 10.00177 seconds
Sync, iterations: 20, sleep: 0.5 took 10.00660 seconds
Sync, iterations: 1, sleep: 2 took 2.00037 seconds
Sync, iterations: 2, sleep: 1 took 2.00064 seconds
asyncio, iterations: 5, sleep: 2 took 2.00471 seconds
Sync, iterations: 20, sleep: 0.1 took 2.00696 seconds
asyncio, iterations: 2, sleep: 2 took 2.00804 seconds
asyncio, iterations: 1, sleep: 2 took 2.01276 seconds
asyncio, iterations: 20, sleep: 2 took 2.01287 seconds
Sync, iterations: 5, sleep: 0.5 took 2.50193 seconds
Sync, iterations: 20, sleep: 1 took 20.00749 seconds
Sync, iterations: 2, sleep: 2 took 4.00105 seconds
Sync, iterations: 20, sleep: 2 took 40.00650 seconds
Sync, iterations: 5, sleep: 1 took 5.00185 seconds
                                            </pre><br><span class="important">or, </span>if preferred read as a horse
                                    race:
                                    <div class="code">
<pre>
The Great Sleep Race: Sync vs Threading vs Asyncio!
In the lead:

Synchronous execution takes the top spot for single tasks (Sync, 1, sleep). It finishes in a blazing 0.10 seconds!
Threading contenders:

They struggle with single tasks, but shine with multiple. Threading with 2 threads (Threading, 2, sleep) comes in second at 0.10 seconds.
As the number of threads increases, performance dips slightly due to overhead.
Asyncio stumbles:

Surprisingly, Asyncio lags behind for all test cases, even with multiple tasks. It seems like these short sleeps aren't ideal for its asynchronous style.
The real slowpokes:

Synchronous execution with multiple tasks (Sync, 50+) falls far behind, taking minutes to complete due to waiting for each sleep to finish.
So, the winner is...

It depends! For quick single tasks, synchronous execution wins. For multiple tasks with waiting (like network requests), threading might be faster. Asyncio shines when dealing with many I/O bound tasks that don't rely heavily on CPU power.
</pre>
                                </div>
                                </div>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Formatting</mat-panel-title>
                                </mat-expansion-panel-header>

                                Numbers, fixed decimal places:<br>
                                <div class="code">
                                    <pre>
super_long_number = 12345678923423.4234234230
print(f"super_long_number with 2 percision: &#123;super_long_number:.2f&#125;")
</pre>
                                </div>Results in <span class="important">12,345,678,923,423.42</span>
                                <br><br>
                                Numbers, commas:<br>
                                <div class="code">
                                    <pre>
super_long_number = 12345678923423.4234234230
print(f"super_long_number: &#123;super_long_number:.0f&#125;")
</pre>
                                </div>Results in <span class="important">12,345,678,923,423</span>
                                <br><br>
                                Scientific:<br>
                                <div class="code">
                                    <pre>
super_long_number = 12345678923423.4234234230
print(f"Number: &#123;super_long_number:.2e&#125;")
</pre>
                                </div>Results in <span class="important">1.23e+13</span>
                                <br>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Constructor</mat-panel-title>
                                    <mat-panel-subtitle>Constructor is: <span class="code">def __init__(self,
                                            &lt;PARAMS&gt;):</span></mat-panel-subtitle>
                                </mat-expansion-panel-header>
                                <div class="code">
                                    <pre>
def __init__(self, &lt;PARAMS&gt;):
    pass
</pre>
                                </div>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>List Comphrehension</mat-panel-title>
                                    <mat-panel-subtitle>Stay Calm! <span class="code">[b for b in People if
                                            People.Disposition == "calm"]</span></mat-panel-subtitle>
                                </mat-expansion-panel-header>
                                Given you have a list of objects such as and you need to see if you have a lock on a
                                specific NPC:
                                <div class="code">
                                    <pre>
locks = []
class NpcWanderLock:
npc_name = ""
lock = None

def __init__(self, npc_name):
    self.npc_name = npc_name
    self.lock = asyncio.Lock()    
</pre>
                                </div><br><br>

                                Traditionally:
                                <div class="code">
                                    <pre>
for npclock in self.npc_running_wander_event:
    if npclock.npc_name == npc.name:
        continue
</pre>
                                </div><br>
                                Same thing using list comphrehension with a single line of code. <span
                                    class="note">Technically, these will provide different results as the loop will
                                    remain "None" if nothing is found or the found object if something is found. The
                                    list comprehsion, on the other hand, is
                                    a list and will either be a length of 0 if nothing if found or have a single
                                    entry accessed via lock[0].</span>
                                <div class="code"><span>lock = [x.lock for x in self.npc_running_wander_event if
                                        x.npc_name == npc.name]</span></div><br>
                                Which is shorthand for:<br>
                                From the object <span class="important">"x"</span>, give me the attribute <span
                                    class="important">"lock" only if</span> the name of the object (x.npc_name) is
                                the name we're looking for (npc.name)

                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>super SuPer SUpER SUPER!</mat-panel-title>
                                </mat-expansion-panel-header>
                                When working with inheritance, it can sometimes be handly to work directly with the
                                parent class.

                                Take for example a structure like this (known as a "factory" pattern):
                                <div class="code">
                                    <pre>
class Npc:
    def __init__(self):
        print("So am I!!!")

class Guard(Npc):
    def __init__(self):
        print("I'm being constructed baby!")

bob_the_guard = Guard()
</pre>
                                </div>
                                <br>
                                <button mat-button color="accent" (click)="clickAnswerTwo()" class="question"><mat-icon
                                        class="questionmark">question_mark</mat-icon>Will the
                                    contents have both print statements?</button>
                                <div *ngIf="answerTwo != ''" class="answer">
                                    &#123;&#123;answerTwo&#125;&#125;<br>
                                    It can sometimes be handy to call the base/parent constructor. For example, if
                                    your parent constructor has a optional parameter "name":
                                    <div class="code">
                                        <pre>
class Npc:
    name = ""
    def __init__(self, name=""):
        print("So am I!!!")
        if name != "":
            self.name = name

        print(f"And my name is: &#123;self.name&#125;")

class Guard(Npc):
    def __init__(self):
        print("I'm being constructed baby!")
        super().__init__(name="Maximus")

bob_the_guard = Guard()
</pre>
                                    </div>
                                    <div>
                                        <pre>
I'm being constructed baby!
So am I!!!
And my name is: Maximus
</pre>
                                    </div>

                                </div>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Multi-line comment</mat-panel-title>
                                    <mat-panel-subtitle>Triple Quotes: <span
                                            class="code">"""</span></mat-panel-subtitle>
                                </mat-expansion-panel-header>
                                <div class="code">
                                    <pre>
player_stats = f"""        
Hello &#123;player.name&#125;&lt;br&gt;
**************************************************&lt;br&gt;
Level: &#123;player.level&#125;&lt;br&gt;
Experience: &#123;player.experience&#125;&lt;br&gt;
**************************************************&lt;br&gt;
You have the following attributes:&lt;br&gt;
* Health &#123;player.stats.current_hp&#125; of &#123;player.stats.max_hp&#125;&lt;br&gt;
* Strength &#123;player.stats.strength&#125;&lt;br&gt;
* Agility &#123;player.stats.agility&#125;&lt;br&gt;
* Determination &#123;player.stats.determination&#125;&lt;br&gt;
* Faith &#123;player.stats.faith&#125;&lt;br&gt;
* Intelligence &#123;player.stats.intelligence&#125;&lt;br&gt;
* Perception &#123;player.stats.perception&#125;&lt;br&gt;
Current Conditions and Aielments:&lt;br&gt;
* Feriocity &#123;player.stats.feriocity.name.capitalize()&#125;&lt;br&gt;
* Resting &#123;player.stats.is_resting&#125;&lt;br&gt;
* Poisoned &#123;player.stats.is_posioned&#125;&lt;br&gt;
**************************************************&lt;br&gt;
"""
</pre>
                                </div>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Shallow Vs. Deep copy</mat-panel-title>
                                </mat-expansion-panel-header>
                                <div class="code">In most cases, Python uses shallow copying for variables. They
                                    means when you do something like this:
                                    <div class="code">
                                        <pre>
monsters_a = []
monsters_b = []
monsters_a = monsters_b
monsters_a.append("Jerry")
</pre>
                                        <button mat-button color="accent" (click)="clickAnswerOne()"
                                            class="question"><mat-icon class="questionmark">question_mark</mat-icon>What
                                            is the contents of
                                            monsters_b?</button>

                                        <div *ngIf="answerOne != ''" class="answer">
                                            &#123;&#123;answerOne&#125;&#125;;
                                            <span class="code">print(monsters_b)</span><span
                                                class="answer">['Jerry']</span>
                                            <br><br>Yup, Jerry got into list b<br>
                                            This is a shallow copy meaning that there's simply a refererence between
                                            list a
                                            and list b. What happens to one, happens to the other. We need to do a
                                            deep copy
                                            to separate the contents.<br><br>The can be done using deepcopy():
                                            <div class="code">
                                                <pre>
monsters_a = []
monsters_b = []
monsters_a = deepcopy(monsters_b)
monsters_a.append("Jerry")
<span class="code">print(monsters_b)</span><span class="answer">['']</span>
</pre>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Try/Except</mat-panel-title>
                                </mat-expansion-panel-header>
                                Python has a nice enhancement for try/catches, traceback:
                                <div class="code">
                                    <pre>
try:
    <span class="comment">&lt;CODE WE WISH TO RUN&gt;</span>
except websockets.ConnectionClosedOK: <span class="comment"><mat-icon>arrow_back</mat-icon> each condition we wish to check (the more the better!)</span>
    LogUtils.warn(f"Someone left. Grin and bear it.  Grin and bear it.  We're going to move on people!", logger)
except KeyboardInterrupt: <span class="comment"><mat-icon>arrow_back</mat-icon> another condition</span>
    loop.stop()
except:
    LogUtils.error(
        f"An error occurred!\nException:\n&#123;traceback.format_exc()&#125;", logger <span class="comment"><mat-icon>arrow_back</mat-icon> format_exc() is an easy way to provide good stacktrace information</span>
    )
</pre>
                                </div><br>
                                Example output:<br>
                                <div class="code">
                                    <pre>
Traceback (most recent call last):
File "&lt;PATH&gt;\&lt;FILE&gt;", line &lt;LINE NUMBER&gt;, in main
    message = await websocket.recv()
            ^^^^^^^^^^^^^^^^^^^^^^
File "C:\Local\Programs\Python\Python312\Lib\site-packages\websockets\legacy\protocol.py", line 568, in recv
    await self.ensure_open()
File "C:\Local\Programs\Python\Python312\Lib\site-packages\websockets\legacy\protocol.py", line 948, in ensure_open
    raise self.connection_closed_exc()
websockets.exceptions.ConnectionClosedOK: received 1005 (no status received [internal]); then sent 1005 (no status received [internal])
</pre>
                                </div>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Ternary in Python</mat-panel-title>
                                    <mat-panel-subtitle><span class="code">True if result is not None else
                                            False</span></mat-panel-subtitle>
                                </mat-expansion-panel-header>
                                The typical ternary operation found in most languages can be represented like this
                                in
                                Python:<br>
                                <span class="code">result == null ? true : false</span> <span
                                    class="comment"><mat-icon>arrow_back</mat-icon> the yoozh</span><br>
                                <span class="code">True if result is not None else False</span> <span
                                    class="comment"><mat-icon>arrow_back</mat-icon> Python</span>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Working with large numbers</mat-panel-title>
                                    <mat-panel-subtitle><span class="code">t =
                                            ThreadingExamples(1_000_000)</span></mat-panel-subtitle>
                                </mat-expansion-panel-header>
                                Use underscores as a visual separator for large numbers.
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Python project file organization</mat-panel-title>
                                    <mat-panel-subtitle>__init__.py</mat-panel-subtitle>
                                </mat-expansion-panel-header>
                                To use subfolders to better organize your code, a file must be created called <span
                                    class="file">__init__.py</span>.

                                The __init__.py files are required to make Python treat directories containing the
                                file
                                as packages (unless using a namespace package, a relatively advanced feature). This
                                prevents directories with a common name, such as string, from unintentionally hiding
                                valid modules that occur later on the module search path. In the simplest case,
                                __init__.py can just be an empty file, but it can also execute initialization code
                                for
                                the package or set the __all__ variable, described later.

                                This will no longer be necessary in Python 3.3+

                                <ul>
                                    <li>To access this subpackage, refer to it with a period: <span class="code">from
                                            races.goblin import Goblin</span></li>
                                </ul>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Make a class JSON serializable</mat-panel-title>
                                </mat-expansion-panel-header>
                                For both troubleshooting and sending traffic between hosts, I find it useful to
                                often take a complete class structure and dump it as a JSON string. In C#, I use <span
                                    class="code">JsonSerializer.Serialize(x);</span> (Core) or <span
                                    class="code">JsonConvert.SerializeObject(x);</span> (Standard).

                                Make a class JSON serializable in Python<br>
                                Take this class:
                                <div class="code">
                                <pre>
class LogEntry:
file_name = None
description = None        
def __init__(self, file_name, description) -> None:
    self.file_name = file_name
    self.description = description                                            
</pre>
                                </div>

                                I often find it necessary to convert this into a string. One reason is to sent to a
                                website or API in the form of JSON. to make the above code into a JSON string, a
                                couple
                                options are available:<br>
                                Use <span class="important">jsonpickle</span>, it's a library designed to take
                                Python objects and convert them into JSON.<br>
                                Update object with this method:
                                <div class="code">
                                <pre>
def to_json(self):
    return jsonpickle.encode(self)
</pre>
                                </div>
                                to call it:<span class="code">&lt;OBJECT&gt;.to_json()</span><br>
                                Example output:<br>
                                <div class="code">
                                <pre>
&#123;"py/object": "aiimages.AIImages.LogEntry", "file_name": "townsmeeblacksmithbackroomroom1720017333.png", "description": "You are in the blacksmith's back Room.  A hot forge still burns smoldering coals."&#125;
    </pre>
                                </div>

                                The JSON string can be read back into an object with <span
                                    class="code">json.loads(item)</span> and then
                                each JSON object can be referenced as a dictionary: <span class="code">description =
                                    item["description"]</span>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Inheritence</mat-panel-title>
                                </mat-expansion-panel-header>

                                Inheritence in Python looks like this:<br><br>If we have these three classes:<ul>
                                    <li>Kobold - Contains specific infformation on the Kobold races. The factory for
                                        generating Kobolds in the world.</li>
                                    <li>BaseStats - Contains general attributes of all races (HP, strength,
                                        intelligence, ect)
                                        <div class="code">
                                        <pre>
class BaseStats(Utility):
    hp = 0
    strength = 0
    agility = 0
    location = 0
    perception = 0
    determination = 0
</pre>
                                        </div>
                                    </li>
                                    <li>Utility - Mostly ENUMs with shared data
                                        <div class="code">
                                            <pre>
class Utility(MudEvents):  
    class Share:
        WORLD_NAME = "Illisurom"
        PLAYER_BASE_REST_WAIT_SECS = 2
                                        
        class EnvironmentTypes(Enum):
            TOWNSMEE = 1,
            BEACH = 2,
            FOREST = 3,
            JUNGLE = 4,
            BREACH = 5,
            GRAVEYARD = 6
            
        class Races(Enum):
            HUMAN = 0,
            KOBOLD = 1,
            GOBLIN = 2,
            HALFLING = 3,
            HALFOGRE = 4,
            ORC = 5,
            ELF = 6,
            FAE = 7,
            NYRRISS = 8,
            ARGUNA = 9,
            EAREA = 10
</pre>
                                        </div>
                                    </li>
                                </ul>

                                This could be structured like this:
                                <div class="code">
                                <pre>
class Kobold(BaseStats):
    class BaseStats(Utility):
</pre>
                                </div>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Docstrings..</mat-panel-title>
                                </mat-expansion-panel-header>
                                Docstring example:
                                <div class="code">
                                <pre>
<strong>def [function_name]</strong>([parameters, i.e. variable names separated by commas]):
<span class="comment">
""" docstring that describes function's usage """
[statements e.g. operations, function calls, return statement]
return [value]
</span>
</pre>
                                </div>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Enums!!</mat-panel-title>
                                </mat-expansion-panel-header>
                                Enums are a great way to keep your code clean and organized. I use them extensively
                                when communicating back and forth with a website or API. They're also great for
                                keeping managing constants.<br><br>
                                To create an enum class, just inherit from Enum:<br>
                                <div class="code">
                                    <pre>
    class GameOfThronesDragons(Enum):
        DROGON = 1
        RHAEGAL = 2
        VISERION = 3
    </pre>
                                </div><br>
                                <span class="code">print(f"Who's a cute little dragon? Yes,
                                    &#123;GameOfThronesDragons.DROGON.name&#125; is a cute little
                                    dragon!")</span><br>
                                <span class="important">Who's a cute little dragon? Yes, DROGON is a cute little
                                    dragon!</span><br><br>
                                An enum class can be treated as a list: <span class="code">random.choice(<span
                                        class="important">list(</span>Monsters<span
                                        class="important">)</span>)</span><br>
                                <div class="code">
                                    <pre>
class Monsters(Enum):
    SKELETON = 1
    ZOMBIE = 2   
print(f"A rotting &#123;random.choice(list(Monsters)).name.lower()&#125; is to your left? What do you do?")             

</pre>
                                </div><span class="important">A rotting skeleton is to your left? What do you
                                    do?</span>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>IS is better!</mat-panel-title>
                                </mat-expansion-panel-header>
                                Prefer <span class="important">if my_object is None</span> over <span
                                    class="important">if my_object == None</span> - Small difference (see below) in
                                comparison.<br>Using "is" keyword is faster since fewer operations are perforemd:
                                <div class="code">
                                    <pre>
class NewObject:
    my_oject = NewObject()
    
print(my_oject == None)
# True

print(my_oject is None)
# False

print(my_oject is not None)
# True
</pre>
                                </div>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Reflection</mat-panel-title>
                                </mat-expansion-panel-header>
                                Reflection is the ability of a program to examine and modify its own structure and
                                behavior at runtime. Python has a module called <span class="important">inspect</span>
                                that provides several functions to help
                                get information about live objects.<br><br>I wrap all methods and classes with:
                                <div class="code">
                                    <pre>
method_name = inspect.currentframe().f_code.co_name
logger.debug(f"&#123;method_name&#125;: enter")
...
logger.debug(f"&#123;method_name&#125;: exit")
</pre>
                                </div>
                                This will provide the method name and the line number of the method:<br>
                                <div class="code">
                                    <pre>
2024-07-19 07:02:35,411 [MainThread] [DEBUG]  get_room: enter, room_id: &lt;room.Room object at 0x000001DCB19FACF0&gt;
2024-07-19 07:02:35,411 [MainThread] [DEBUG]  get_room: room "[&lt;room.Room object at 0x000001DCB21C8830&gt;]"
2024-07-19 07:02:35,412 [MainThread] [DEBUG]  get_room: exit, returning room "Town Smee - Town Square"
</pre>
                                </div>

                            </mat-expansion-panel>
                        </li>
                    </ul>
                </div>
                <div>
                    These are utility libraries I've written to ease miscellaneous tasks..
                    <dl>
                        <dt>Utility functions for working with Excel</dt>
                        <dd><a href="assets/libraries/excel_utils.py">excel_utils.py</a></dd>
                        <dt>Utility functions for setting/deleting enviroment variables</dt>
                        <dd><a href="assets/libraries/envion_var_utils.py">envion_var_utils.py</a></dd>
                        <dt>Utility functions for reading event logs</dt>
                        <dd><a href="assets/libraries/event_log_utils.py">event_log_utils.py</a></dd>
                        <dt>Utility functions for working with files</dt>
                        <dd><a href="assets/libraries/file_utils.py">file_utils.py</a></dd>
                        <dt>Miscellaneous stuff... a sleep_for(seconds) and get_duration(start_time) function</dt>
                        <dd><a href="assets/libraries/helper_utils.py">helper_utils.py</a></dd>
                        <dt>Utility functions for network-related functions</dt>
                        <dd><a href="assets/libraries/ip_helpers.py">ip_helpers.py</a></dd>
                        <dt>Utility functions for logging to file and optionally sending to MS Teams / Slack</dt>
                        <dd><a href="assets/libraries/log_utils.py">log_utils.py</a></dd>
                        <dt>Utility functions for sending messages to MS Teams</dt>
                        <dd><a href="assets/libraries/msteams_utils.py">msteams_utils.py</a></dd>
                        <dt>Single is_windows_64bit function</dt>
                        <dd><a href="assets/libraries/platform_utils.py">platform_utils.py</a></dd>
                        <dt>Utility functions for collecting process information</dt>
                        <dd><a href="assets/libraries/process_utils.py">process_utils.py</a></dd>
                        <dt>Utility functions for working with Pyunit</dt>
                        <dd><a href="assets/libraries/pyunit_utils.py">pyunit_utils.py</a></dd>
                        <dt>Utility functions for working with registry</dt>
                        <dd><a href="assets/libraries/registry_utils.py">registry_utils.py</a></dd>
                        <dt>Utility functions for working with Selenium</dt>
                        <dd><a href="assets/libraries/selenium_utils.py">selenium_utils.py</a></dd>
                        <dt>Utility functions for sending messages to Slack</dt>
                        <dd><a href="assets/libraries/slack_utils.py">slack_utils.py</a></dd>
                        <dt>Utility functions for convert complicated structures into strings</dt>
                        <dd><a href="assets/libraries/string_utils.py">string_utils.py</a></dd>
                        <dt>Utility functions for running commands</dt>
                        <dd><a href="assets/libraries/subprocess_utils.py">subprocess_utils.py</a></dd>
                        <dt>Utility functions for passing arguments to Python script</dt>
                        <dd><a href="assets/libraries/sysargs_utils.py">sysargs_utils.py</a></dd>
                    </dl>
                </div>
            </div>
            <div><app-comment></app-comment></div>
        </div>
    </mat-card-content>
</mat-card>