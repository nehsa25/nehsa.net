<mat-card class="card" [class.vampire]="userService.appIsDark()" [class.angel]="!userService.appIsDark()">
    <mat-card-header>
        <mat-card-title>
            <h1 data-testid="header-title">TypeScript / JavaScript</h1>
        </mat-card-title>
    </mat-card-header>
    <mat-card-content>
        <div class="commentgrid topics">
            <div><app-related-content></app-related-content></div>
            <div>
                <div>
                    <ul>
                        <li>
                            <mat-expansion-panel expanded>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Naming Conventions</mat-panel-title>
                                </mat-expansion-panel-header>
                                <ul>
                                    <li>Upper case with underscore (_) between multiple words</li>
                                    <li>Use camelCase for variable and function names</li>
                                    <li>Use camelCase of class members, interface members, methods and
                                        methods
                                        parameters</li>
                                    <li>Use PascalCase for class names and interface names.</li>
                                    <li>Use PascalCase for enums and camelCase for enum members</li>
                                    <li>Use UPPERCASE for constants</li>
                                </ul>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Best Practices / Tips</mat-panel-title>
                                </mat-expansion-panel-header>
                                <ul>
                                    <li>Use private variables when possible. (public is needed if referenced via
                                        HTML)</li>
                                    <li>Don't use negative names for boolean variables. e.g. this: <span
                                            class="code">const
                                            isNotSet = true;</span> would be better as <span class="code">const
                                            isSet =
                                            false;</span> </li>
                                    <li>Use "const" whenever possible when a variable is not intended to
                                        change instead of
                                        var/let</li>
                                    <li>var Vs. let &hyphen; var is function scoped, let is block scoped
                                    </li>
                                    <li>Pass Intellisense to VSCode: /** comment */ above function</li>
                                </ul>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>JavaScript Vs. TypeScript</mat-panel-title>
                                </mat-expansion-panel-header>
                                I often get confused whether I'm using JavaScript/TypeSCript and how to tell the
                                difference. Here's a breakdown:
                                <table>
                                    <tr>
                                        <th>JavaScript</th>
                                        <th>TypeScript</th>
                                    </tr>
                                    <tr>
                                        <td>Dynamic typing (var)<br>
                                            <ul>
                                                <li>Function-scoped: variables are available within the function they
                                                    are declared</li>
                                                <li>Loose equality checking (the type of the variable is not checked)
                                                </li>
                                            </ul>
                                        </td>
                                        <td>Static typing (let, const)
                                            <ul>
                                                <li>Block-scoped: Typescript has finer control over variable scoping
                                                    with block scoping (only within parent curly braces).</li>
                                                <li>Strict equality checking</li>
                                                <li>As TypeScript is a superset of
                                                    JavaScript, it can always be compiled to
                                                    JavaScript.</li>
                                            </ul>
                                        </td>
                                    </tr>
                                </table>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Strict/Loose Comparisions</mat-panel-title>
                                    <mat-panel-description>== Vs. ===</mat-panel-description>
                                </mat-expansion-panel-header>JavaScript/TypeScript is the only language I'm familar with
                                that has
                                both strict and loose comparisons.
                                <dl>
                                    <dt>Strict Comparision</dt>
                                    <dd>Checks if the two values are equal in type and value</dd>
                                    <dt>Loose Comparision</dt>
                                    <dd>Checks if the two values are equal in value only</dd>
                                </dl>

                        <li>Loose Vs. Strict Equality Checking
                            <ul>
                                <li>Using a <span class="importantish">&quot;loose-check&quot; (two
                                        ==)</span>
                                </li>
                                <li>
                                    Using a <span class="importantish">&quot;strict-check&quot; (three
                                        ===)</span>
                                </li>
                            </ul>

                            <br><br>
                            e.g. Depending on the comparison used, we can get different behavior. The best practice
                            is to always use the strict comparison that also includes type as it's the more explicit
                            of the two comparisons.<br>
                            <code>
                                                <pre>
const num = 10;
const str = "10";
num === str <span class="comment">// <span class="importantish">false</span> (different types: string/number)</span>
num == str <span class="comment">// <span class="importantish">true</span> (this is true because a cast is performed prior to the equality check)</span>
</pre>
</code>
                        </li>
                        </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Looping</mat-panel-title>
                                    <mat-panel-description>forEach, for...of, for...in</mat-panel-description>
                                </mat-expansion-panel-header>
                                <table class="min-table">
                                    <tr>
                                        <th>Loop</th>
                                        <th>Considerations</th>
                                    </tr>
                                    <tr>
                                        <td>forEach (JavaScript version)</td>
                                        <td>Used to iterate over an array. It's a method of the array object.
                                            <code>
                                                <pre>
const arr = [1, 2, 3];
arr.forEach(function (element) &#123;
    console.log(element);
&#125;);
</pre>
                                            </code>
                                            <div class="result">1<br>2<br>3</div>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>forEach (TypeScript version)</td>
                                        <td>Used to iterate over an array. It's a method of the array object.

                                            <code>
                                                <pre>
const arr = [1, 2, 3];
arr.forEach(element => &#123;
    console.log(element);
&#125;);
</pre>
                                            </code>
                                            <div class="result">1<br>2<br>3</div>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>for...of</td>
                                        <td>Used to iterate over an array. It's a new feature of ES6 and can be used to
                                            iterate any iterable object.
                                            <code>
                                                <pre>
const arr = [1, 2, 3];
for (const element of arr) &#123;
    console.log(element);
&#125;
</pre>
                                            </code>
                                            <div class="result">1<br>2<br>3</div>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>for...in</td>
                                        <td>Used to iterate over the properties of an object. It's a new feature of
                                            ES6.<br><br>
                                            <code>
                                                <pre>
const obj = &#123; a: 1, b: 2, c: 3 &#125;;
for (const key in obj) &#123;
    console.log(key);
&#125;
</pre>
                                            </code>
                                            <div class="result">a<br>b<br>c</div>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>for</td>
                                        <td>Can't forget this one!</td>
                                    </tr>
                                </table>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Currying</mat-panel-title>
                                    <mat-panel-description>Where a
                                        function takes a single argument and returns a new function that takes the
                                        remaining arguments. This can be useful for creating more flexible and
                                        composable functions.
                                    </mat-panel-description>
                                </mat-expansion-panel-header>
                                A function written like this:<br>
                                <code>
                                    <pre>
const add = (a: number, b: number) => a + b;
console.log(add(1, 2));
</pre>
                                </code>

                                Can also be written using currying:<br>
                                <code>
                                    <pre>
const add = (a: number) => (b: number) => a + b;
console.log(add(1)(2));
</pre>
                                </code>
                                <div class="result">Both product 3</div>

                                Why? It doesn't seem like much of a difference, but it can be useful for creating more
                                flexible and composable functions. For example a function that take a function and a
                                value and returns a new function that takes a value and returns the result of the
                                original function applied to the two values:
                                <code>
                                    <pre>
const apply = (fn: (a: number, b: number) => number, a: number) => (b: number) => fn(a, b);
const add = (a: number, b: number) => a + b;
const add1 = apply(add, 1);
console.log(add1(2));
</pre>
                                </code>
                                <div class="result">3</div>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>JavaScript Files</mat-panel-title>
                                </mat-expansion-panel-header>
                                <dl>
                                    <dt>.js</dt>
                                    <dd>Standard untyped JavaScript file</dd>
                                    <dt>.mjs</dt>
                                    <dd>ES6 module, an example is a Node.js module which can be
                                        imported using the import keyword</dd>
                                    <dt>.cjs</dt>
                                    <dd>CommonJS module, an example is a Node.js module which can be
                                        imported using the require keyword</dd>
                                    <dt>.jsx</dt>
                                    <dd>A React JS component</dd>
                                    <dt>.ts</dt>
                                    <dd>Standard TypeScript file</dd>
                                    <dt>.tsx</dt>
                                    <dd>A React TypeScript component</dd>
                                </dl>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>ES6 (AKA ECMAScript 2015) Syntax</mat-panel-title>
                                    <mat-panel_description>ES6 Goodness! ES6 is the latest version of JavaScript and has
                                        major enhancements over ES5.
                                    </mat-panel_description>
                                </mat-expansion-panel-header>
                                Although not comprehensive, here are some of the features of ES6:
                                <dl>
                                    <dt>Arrow functions</dt>
                                    <dd>
                                        Shorter syntax for functions.<br>
                                        Example:<br>
                                        <code class="code">
                                            getDistanceInFathoms = (distanceInFeet: number) => &#123; return distanceInMeters / 6 &#125;;
                                        </code><br>
                                        <div class="result">console.log(getDistanceInFathoms(12)):
                                            {{getDistanceInFathoms(12)}} fathoms</div><br>

                                        Is the same as:<br><br>

                                        <code>
<pre>
function getDistanceInFathoms(distanceInFeet) &#123;
    return distanceInFeet / 6;
&#125;
</pre>
                                        </code><br>
                                        <div class="result">console.log(getDistanceInFathoms(12)): 2 fathoms</div>
                                    </dd>
                                    <dt>Classes</dt>
                                    <dd>Classes are a template for creating objects. They encapsulate data for the
                                        object. An example of a ES6 change is the introduction of the class keyword.
                                    <dt>Template literals</dt>
                                    <dd>Template literals are string literals allow for interpolation and multiline
                                        strings similar to string interpolation features in Perl, Python, and more. They
                                        are enclosed by the backtick (`).
                                    </dd>
                                    <dt>Let and Const</dt>
                                    <dd>Let and Const are block-scoped variables. Let is the new var and Const is a
                                        constant that cannot be changed.
                                    </dd>
                                    <dt>Default parameters</dt>
                                    <dd>Default parameters allow for default values to be set for function parameters.
                                        Example: <code>function
                                        getPie(type = "apple") &#123;return type;&#125;</code></dd>
                                    <dt>Rest Operator</dt>
                                    <dd>The rest operators allows for an indefinite number of arguments to be passed to
                                        a function. Example:
                                        <code>function
                                        addStuff(...numbers) &#123;return numbers.reduce((acc, cur) => acc + cur, 0);&#125;</code><br><br>

                                        Resulting in:<br>
                                        <code>
                                            <pre>
console.log(addStuff(1, 2, 3, 4, 5));
15
                                            </pre>
                                        </code>
                                    </dd>
                                    <dt>Spread Opeator</dt>
                                    <dd>The spread operator allows for an array to be expanded into individual elements.
                                        Example: <code>const
                                        numbers = [1, 2, 3, 4, 5];<br>console.log(addStuff(...numbers));</code><br><br>
                                        Resulting in:<br>
                                        <code>
                                            <pre>
console.log(addStuff(1, 2, 3, 4, 5));
15
                                            </pre>
                                        </code>
                                    </dd>
                                    <dt>Destructuring</dt>
                                    <dd>Destructuring allows for an object or array to be broken down into individual
                                        elements. Example: <code>const
                                        &#123;name, age&#125; = person;</code></dd>
                                    <dt>Modules</dt>
                                    <dd>Modules allow for code to be split into separate files. The export keyword is
                                        used to export a module and the import keyword is used to import a module.</dd>
                                    <dt>Iterators</dt>
                                    <dd>Iterators allow for objects to be iterated over. The Symbol.iterator is used to
                                        create an iterator.</dd>
                                    <dt>Generators</dt>
                                    <dd>Generators are functions that can be paused and resumed. The function* keyword
                                        is used to create a generator.</dd>
                                    <dt>Maps</dt>
                                    <dd>Maps are new data structures in ES6. Maps are collections of key-value
                                        pairs. e.g. <br>
                                        <code>
<pre>
const myMap = new Map();
myMap.set("key1", "value1");
myMap.set("key2", "value2");
console.log(myMap.get("key1"));
</pre>
                                        </code>
                                    </dd>
                                    <dt>Sets</dt>
                                    <dd>Sets are new data structures in ES6. Maps are collections of key-value
                                        pairs and Sets are collections of unique values. e.g. <br>
                                        <code>
<pre>
const mySet = new Set();
mySet.add("value1");
mySet.add("value2");
console.log(mySet.has("value1"));
</pre>
                                        </code>
                                    </dd>
                                    <dt>Proxies</dt>
                                    <dd>Proxies allow for objects to be intercepted and custom behavior to be defined.
                                        The Proxy object is used to create a proxy. e.g. <br>
                                        <code>
<pre>
const handler = &#123;
    get: function(target, name) &#123;
        return name in target ? target[name] : 42;
    &#125;
&#125;

const p = new Proxy(&#123;a: 1&#125;, handler);
console.log(p.a, p.b);
</pre>
                                        </code><br><br>

                                        Resulting in:<br>
                                        <code>
<pre>
1 42
</pre>
                                        </code><br><br>

                                        This is useful for things like logging and validation.
                                    </dd>
                                    <dt>Symbol</dt>
                                    <dd>Symbols are unique and immutable data types. The Symbol function is used to
                                        create a symbol. e.g. <br>
                                        <code>
<pre>
const mySymbol = Symbol("mySymbol");
console.log(mySymbol);
</pre>
                                        </code><br><br>

                                        Resulting in:<br>
                                        <code>
<pre>
Symbol(mySymbol)
</pre>
                                        </code><br><br>Used for object properties that should be unique. For example,
                                        on a user service, they may be used for a user ID.
                                    </dd>
                                    <dt>Promises</dt>
                                    <dd>Promises are used to handle asynchronous operations. The Promise object is used
                                        to create a promise. e.g.<br>
                                        <code>
<pre>
const myPromise = new Promise((resolve, reject) => &#123;

    setTimeout(() => &#123;
        resolve("I'm resolved!");
    &#125;, 1000);

&#125;);

myPromise.then((value) => &#123;
    console.log(value);
&#125;);
</pre>
                                        </code>
                                    </dd>
                                    <dt>Async/Await</dt>
                                    <dd>Async/Await is a new way to write asynchronous code. The async and await
                                        keywords are used to write asynchronous code that looks synchronous. Performance
                                        is better than using Promises. e.g.
                                        <code>
<pre>
async function myAsyncFunction() &#123;
    const value = await myPromise();
    console.log(value);
&#125;
</pre>
                                        </code>
                                    </dd>
                                </dl>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Constuctor</mat-panel-title>
                                </mat-expansion-panel-header>
                                A constuctor in typescript is simply the keyword constructor:
                                <code>
                                    <pre>
export class MyClass &#123;
    constructor() &#123;
        <span class="comment">// Look ma! I construct!</span>
    &#125;
&#125;
</pre>
</code>

                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Accessors</mat-panel-title>
                                </mat-expansion-panel-header>
                                I'm not steadfast in using accessors. They often lead to extra code
                                lines that don't
                                need to be there. They can be helpful for a few things, though:
                                <ul>
                                    <li>Getters can be used to calculate a value based on other values
                                    </li>
                                    <li>Setters can be used to trigger an event when a value is changed
                                    </li>
                                    <li>
                                        Troubleshooting:<br>
                                        <code>
                                            <pre>
private _reversify = false;

get reversify(): boolean &#123;
console.log("I've been gotten! The horror! The horror! " + this._reversify);
return this._reversify;
&#125;

set reversify(value: boolean) &#123;
console.log("The thrill! The excitement! I've been set! (value: " + value + ")");
this._reversify = value;
&#125;

// Usage
this.reversify = true;
Produces:
The thrill! The excitement! I've been set! (value: true)

console.log(this.reversify);
Produces:
I've been gotten! The horror! The horror! true
</pre>
</code>
                                    </li>
                                </ul>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Interpolation</mat-panel-title>
                                </mat-expansion-panel-header>
                                Interpolation is a way to insert a variable into a string. In TypeScript, it's done by
                                using the $&#123;&#125; syntax. e.g.:
                                <code>
                                    <pre>
const name = "Bob";
console.log(`Hello, $&#123;name&#125;!`);
</pre>
                                </code>
                                <div class="result">Hello, Bob!</div>
                                <span class="additional-note">The use of backticks (`) is required for interpolation. In
                                    TypeScript, single quotes ('') and double quotes ("") are interchangeable and used
                                    for literal strings.</span>
                            </mat-expansion-panel>
                        </li>
                        <li>
                            <mat-expansion-panel>
                                <mat-expansion-panel-header>
                                    <mat-panel-title>Troubleshooting</mat-panel-title>
                                </mat-expansion-panel-header>
                                <ul>
                                    <li>
                                        <span class="question">Property '_answers' has no initializer and is not
                                            definitely assigned in the constructor.</span><br><br>
                                        <div class="answer">This is caused if this setting is enabled (which it should
                                            be) and means we need to fully initialize variables.
                                            <br><br>
                                            <code>
                                                <pre>
"compilerOptions": &#123;
    "strictPropertyInitialization": false,
    ...
&#125;  
</pre>
</code><br><br>
                                            e.g.:
                                            <span class="code">private _answers: string[] = [];</span>
                                        </div>
                                    </li>
                                </ul>
                            </mat-expansion-panel>
                        </li>
                    </ul>
                </div>
                <div><app-comment></app-comment></div>
            </div>
        </div>
    </mat-card-content>
</mat-card>